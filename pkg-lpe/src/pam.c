//
//  pam_parser.c
//  pkg-lpe
//
//  Created by Michael on 23/05/2023.
//

#include "pam.h"
#include <stdlib.h>
#include <string.h>
#include "logging.h"

// We're more than likely writing a smaller pam file than we have,
// so in order to ensure its valid, pad with comment char
#define PAD_CHAR '#'

int PaddingLength(size_t* paddingRequired) {
    FILE* fp = fopen(OVERWRITE_FILE, "r");
    
    if( NULL == fp )
    {
        ERROR("failed to open %s\n", OVERWRITE_FILE);
        return 1;
    }
    
    if( NULL == paddingRequired)
    {
        ERROR( "null paddingRequired" );
        return 1;
    }
    
    fseek(fp, 0, SEEK_END);
    size_t originalSize = ftell(fp);
    size_t permissiveLength = strlen(PERMISSIVE_PAM);
    
    SUCCESS("existing %s is %ld bytes\n", OVERWRITE_FILE, originalSize);
    SUCCESS("permissive is %ld bytes\n", permissiveLength);
    
    if(permissiveLength > originalSize)
    {
        ERROR("fail: pam file cannot be larger than permissive pam (%ld > %ld)\n", permissiveLength, originalSize );
        fclose(fp);
        return 1;
    }
    
    *paddingRequired = originalSize - permissiveLength;
    
    fclose(fp);
    
    return 0;
}

int WriteFile(char* dest, char* contents, size_t paddingRequired)
{
    FILE*    fp    =    NULL;
    
    fp = fopen(dest, "w+");
    
    if( NULL == fp )
    {
        ERROR("failed to open '%s'", TEMP_FILE);
        return 1;
    }
    
    size_t bytesWritten = fwrite(contents, 1, strlen(contents), fp);
    
    if( bytesWritten != strlen(contents) )
    {
        ERROR("Tried to write %ld bytes but only wrote %ld\n", strlen(contents), bytesWritten);
        fclose(fp);
        return 1;
    }
    
    char* buff = malloc(paddingRequired);
    
    if( NULL == buff)
    {
        ERROR("failed to malloc buff of size %ld\n", paddingRequired);
        return 1;
    }
    
    for(int i = 0; i < paddingRequired; i++)
    {
        buff[i] = !i ? '\n' : PAD_CHAR;
    }
    
    fwrite(buff, 1, paddingRequired, fp);
    
    fclose(fp);
    free( buff );
    SUCCESS("written %ld bytes to 'overwrite'\n", bytesWritten);
    
    return 0;
}

int ReadPamFile(char** contents)
{
    FILE*     fp      =    NULL;
    size_t    size    =    0;
    
    if( NULL == contents )
    {
        ERROR("Bad contents pointer\n");
        return 1;
    }
    
    fp = fopen(OVERWRITE_FILE, "r");
    
    if( NULL == fp )
    {
        ERROR("Failed to open %s\n", OVERWRITE_FILE);
        return 1;
    }
    
    // Get size
    fseek(fp, 0, SEEK_END);
    size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    
    *contents = calloc(1, size);
    
    if( NULL == *contents )
    {
        ERROR("failed to calloc out pointer\n");
        return 1;
    }
    
    size_t read = fread(*contents, 1, size, fp);
    
    if( read != size )
    {
        ERROR("tried to read %ld bytes, only read %ld\n", size, read);
        return 1;
    }
    
    fclose( fp );
    
    return 0;
}
