//
//  pam_parser.c
//  pkg-lpe
//
//  Created by Michael on 23/05/2023.
//

#include "pam.h"
#include <stdlib.h>
#include <string.h>
#include "logging.h"

// We're more than likely writing a smaller pam file than we have,
// so in order to ensure its valid, pad with comment char
#define PAD_CHAR '#'

int PaddingLength( size_t* paddingRequired ) {
    FILE* fp = fopen(OVERWRITE_FILE, "r");
    
    if( NULL == fp )
    {
        ERROR("failed to open %s\n", OVERWRITE_FILE);
        return 1;
    }
    
    if( NULL == paddingRequired)
    {
        ERROR( "null paddingRequired" );
        return 1;
    }
    
    fseek(fp, 0, SEEK_END);
    size_t originalSize = ftell(fp);
    size_t permissiveLength = strlen(PERMISSIVE_PAM);
    
    SUCCESS("existing %s is %ld bytes\n", OVERWRITE_FILE, originalSize);
    SUCCESS("permissive is %ld bytes\n", permissiveLength);
    
    if(permissiveLength > originalSize)
    {
        ERROR("fail: pam file cannot be larger than permissive pam (%ld > %ld)\n", permissiveLength, originalSize );
        fclose(fp);
        return 1;
    }
    
    *paddingRequired = originalSize - permissiveLength;
    
    fclose(fp);
    
    return 0;
}

int WriteFile( char* dest, char* contents, size_t paddingRequired )
{
    FILE*     fp            =  NULL;
    size_t    bytesWritten  =  0;
    char*     buff          =  NULL;
    int       ret           =  1;

    do {
        fp = fopen(dest, "w+");
        
        if( NULL == fp )
        {
            ERROR("failed to open '%s'", TEMP_FILE);
            break;
        }
        
        bytesWritten = fwrite(contents, 1, strlen(contents), fp);
        
        if( bytesWritten != strlen(contents) )
        {
            ERROR("Tried to write %ld bytes but only wrote %ld\n", strlen(contents), bytesWritten);
            break;
        }
        
        buff = malloc(paddingRequired);
        
        if( NULL == buff)
        {
            ERROR("failed to malloc buff of size %ld\n", paddingRequired);
            break;
        }
        
        for(int i = 0; i < paddingRequired; i++)
        {
            buff[i] = !i ? '\n' : PAD_CHAR;
        }
        
        fwrite(buff, 1, paddingRequired, fp);

        free( buff );
        SUCCESS("written %ld bytes to 'overwrite'\n", bytesWritten);
        ret = 0;

    } while ( false );

    if( NULL != fp )
    {
        fclose( fp );
    }
    
    return ret;
}

int ReadPamFile( char** contents )
{
    FILE*     fp      =  NULL;
    size_t    size    =  0;
    int       ret     =  1;

    do {
        if( NULL == contents )
        {
            ERROR("Bad contents pointer\n");
            break;
        }
        
        fp = fopen(OVERWRITE_FILE, "r");
        
        if( NULL == fp )
        {
            ERROR("Failed to open %s\n", OVERWRITE_FILE);
            break;
        }
        
        // Get size
        fseek(fp, 0, SEEK_END);
        size = ftell(fp);
        fseek(fp, 0, SEEK_SET);
        
        *contents = calloc(1, size);
        
        if( NULL == *contents )
        {
            ERROR("failed to calloc out pointer\n");
            break;
        }
        
        size_t read = fread(*contents, 1, size, fp);
        
        if( read != size )
        {
            ERROR("tried to read %ld bytes, only read %ld\n", size, read);
            break;
        }
        
        ret = 0;
    } while( false );
    
    if( NULL != fp )
    {
        fclose( fp );
    }
    
    return ret;
}
